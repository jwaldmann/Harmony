{-# LANGUAGE TemplateHaskell #-}
{-|
Module      : Tests
Description : 'Arbitrary' instances and QuickCheck tests for the used data types.
-}
module Tests where

import Test.QuickCheck.All (quickCheckAll, verboseCheckAll)
import Test.QuickCheck (Arbitrary(arbitrary), Gen, choose, oneof, quickCheck, verboseCheck, resize, listOf1)
import System.Exit (ExitCode, exitFailure, exitSuccess)

import Types
import GenerateChords

-- | Generate an arbitrary element from a list
chooseOne :: [a] -> Gen a
chooseOne = oneof . map return

-- | Wrapper type to generate integer values inside a predefined range.
-- | Prevents integer overflow when QuickCheck generates random values.
newtype SmallInt = SmallInt Int
    deriving (Eq, Show)
instance Arbitrary SmallInt where
    arbitrary = fmap SmallInt $ choose (fst integerTestRange, snd integerTestRange)
newtype UnsignedSmallInt = UnsignedSmallInt Int
    deriving (Eq, Show)
instance Arbitrary UnsignedSmallInt where
    arbitrary = fmap UnsignedSmallInt $ choose (0, snd integerTestRange)

-- | The low/high bound to use for 'SmallInt' and 'UnsignedSmallInt'
integerTestRange :: (Int, Int)
integerTestRange = (-1000000, 1000000)

instance Arbitrary PitchClass where
    arbitrary = chooseOne pitchClasses

instance Arbitrary MajMin where
    arbitrary = chooseOne possibleValues
        where possibleValues = [minBound..maxBound] :: [MajMin]

instance Arbitrary Tension where
    arbitrary = chooseOne possibleValues
        where possibleValues = [minBound..maxBound] :: [Tension]

instance Arbitrary Chord where
    arbitrary = chord `fmap` (resize 5 randomPitches)
        where randomPitches = listOf1 arbitrary :: Gen [Pitch]

-- Types Tests

-- | Check that 'Tension's are invariant to modulo on pitch values
prop_tensionToSemitones_modulo (SmallInt semitones) =
    let (_, semitonesModOctave) = semitones `divMod` semitonesPerOctave
        tension1 = semitonesToTension semitones
        tension2 = semitonesToTension semitonesModOctave
    in tension1 == tension2

-- | Check conversions between 'Chord's and 'Hand's are inverse to each other
prop_ChordToHand_symmetry (UnsignedSmallInt pitch1) (UnsignedSmallInt pitch2) (UnsignedSmallInt pitch3) =
    let c = chord [pitch1, pitch2, pitch3]
    in c == (toChord . toHand) c

-- GenerateChords Tests

-- | Check that the chord generator generates the correct amount of combinations.
-- Only chords up to a length of 'maxLength' are checked.
-- 'lengthLimit' is a random value generated by QuickCheck.
prop_combinations_correctLength semitones lengthLimit =
    let maxLength = 5
        (_, lengthLimit') = lengthLimit `divMod` maxLength
        semitones' = take lengthLimit' semitones
    in (length . combinations) semitones' == (length allowedOctaveTranspositions)^(length semitones')



-- needed by QuickCheck
return []

main :: IO ExitCode
main = do
    success <- runTests
    if success then exitSuccess else exitFailure

runTests, runTestsVerbose :: IO Bool
runTests = $quickCheckAll
runTestsVerbose = $verboseCheckAll
